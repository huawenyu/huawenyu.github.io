---
layout: post
title:  "git & svn"
date:   2017-02-16 13:31:01 +0800
categories: linux
tags: git svn
---

* content
{:toc}


# QuickStart

[Svn Doc][2]

$ git clone --depth 1 --single-branch file:////home/wilson/workref/fos-git

## config password local

```
$ vi ~/.netrc
machine github.com
       login yourusername
       password yourpassword
machine gitlab.com
       login yourusername@mail
       password yourpassword
```

Git compare with svn


Next we'll take a look at some commands that you will need for working. Following is a list of the common svn commands that we use all the time and their analogs in git.


|         | SVN                                    | Git | git-svn |
| Routine |                                        |     |         |
|         |  - svn checkout http://remote local-dir|     |         |
|         |  - svn up                              |     |         |
|         |  - … modify …                           |     |         |
|         |  - svn diff                             |     |         |
|         |  - svn commit -m "new feature"          |     |         |
|         |  - svn revert -R .                      |     |         |


	git clone --depth 3 git://some/repo myshallowcopyrepo
git pull --all


git checkout -b upstream origin/upstream    <<< trace remote branch
git checkout -b new_feature


git checkout master  # first, update from the remote trunk
git svn rebase        <<< update it to HEAD


git checkout bug123  # next, branch feature rebase
git rebase master      #  bug123 on top of master


###  implement feature ###
git checkout master  # merge feature to trunk
git merge bug123     # this should be a fast-forward


git add file4           <<< only add the changes from some file
<or> git add -i file2     <<< only add part of changes from some file


git diff                    <<< show uncommitted changes
git diff --cached    <<< show the added changes for next commit


git commit -m "commit message" 


git checkout master    
git merge new_feature    <<< merge into master
git commit -am ‘more modify’


git log v2.43.. mydir     <<< view changes since 2.43 tag.
	http://trac.parrot.org/parrot/wiki/git-svn-tutorial 


git svn clone --prefix=svn/ -r465327:HEAD http://.../svn/FortiCache/trunk
                                 <note> -r r465327:HEAD will fail
git svn clone -r HEAD http://.../trunk    <<< only checkout the last version




git svn rebase      <<< like: svn update
git commit -am ‘more modify’


git rebase -i HEAD~10        <<< squash more commit into one or two
git svn dcommit                   <<< send the git commits to svn remote
	Create repository
	svnadmin create ~/myrep


vi ~/myrep/conf/svnserve.conf
vi ~/myrep/conf/passwd


svn mkdir  <dir>
svn import  <file>
svnserve -d
	$ tar zxf frotz.tar.gz
$ cd frotz

$ git init
$ git add . <<< add everything under the current directory
$ git commit -m "Init"
$ git tag -s -m "GIT 0.99.9x" v0.99.9x   <<< make a lightweight, unannotated tag
	

	Clone remote repository
	svn checkout -r<revision> <URL>
	git clone <URL>


=== get the last n revisions
git clone --depth 3 git://some/repo myshallowcopyrepo


=== clone local reps
git clone fos-git fos-git-5.2
cd fos-git-5.2; vi .git/config    <<< change origin url to remote
	=== get the last serveral revisions
 git svn clone -r65000:HEAD <URL> my-dev 


<OR>
    git svn init -s <URL>
    <<< -s svn repos have normal layout, such as trunk, branches, tags
    git svn fetch    <<< 从svn取得所有的版本信息
    git svn fetch -r <rev>
	Clone directly from local filesystem
	

	==clone==
$  git clone --depth 1 --single-branch file:////home/wilson/workref/fos-git    <<< Quickest


$ git clone ssh://username@host.xz/absolute/path/to/repo.git/     <<< forward slash for absolute path on server
<OR>
$ git clone username@host.xz:relative/path/to/repo.git/                <<< a colon (it mustn't have the ssh:// for relative path on server (relative to home dir of username on server machine)


==push,pull==
On the client machine you can push your repo to the server. 
$ git remote add origin ssh://user@server:/GitRepos/myproject.git 
$ git push origin master




	

	backup whole repository
	http://www.if-not-true-then-false.com/2012/svn-subversion-backup-and-restore/ 
svnadmin dump -q /path/to/repo | bzip2 -9 > filename.bz2


svnadmin dump /var/www/svn/testrepo | gzip -9 > /backups/testrepo.dump.gz


svnadmin load /var/www/svn/testrepo < /backups/testrepo.dump
	git bundle create /tmp/repo-proj --all
git clone /tmp/repo-proj newFolder
	

	create patch
	

	==from branch==
git checkout -b feature1
git format-patch master --stdout > fix_feature1.patch


==from commit==
git format-patch HEAD~5
<OR>
git format-patch commit-id-start..commit-id-end


==apply==
git apply --check fix_feature1.patch      <<< check the patch is OK or not
git am --signoff file.patch                  <<< commit the patch with original author information
<OR>
git apply fix_feature1.patch                   <<< apply the changes, not commit them. 


==troubleshoot==
git rebase -i HEAD~5            <<< will open an editor: select or delete commits that you want
	

	List repository info
	svn info
	cat .git/config
git remote show origin
	git svn info
	

	

	

	<git svn clone>


	Update
	svn update
	git pull --all
	git svn rebase






	New branch
	svn copy URL/trunk URL/branches/5.x/trunk
svn copy URL/branches/5.x/trunk URL/branches/5.x/5.0/trunk
	git checkout -b my-new-feature
	

	 Submit
	svn commit -m ‘message’
	git commit -am 'message'
	git svn dcommit -m 'message'
	 Add/Del/Rename
	svn add|delete|rm
	git add|delete|rm
	

	Search & Log
	

	git log -- foo.py bar.py            <<< by file
	

	 conflict
	svn st | grep -e ‘^.{0,6}C’
	

	

	 Check changed
	svn diff
	git diff
	

	

	svn diff --diff-cmd='meld'
	git difftool -t meld b3dc7d75~1 b3dc7d75
	

	Merge
	svn merge
	git merge|rebase
	

	Status
	svn status
svn -q st
	git status
	

	clean for rebuild
	svn st --no-ignore | awk '/^?/{print $2}' | xargs rm -rf


svn status | grep '^?' | awk '{print $2}' | xargs rm -rf
svn status | egrep '^\?' | cut -c 8- | xargs rm
svn status | grep ^\? | cut -c 9- | xargs -d \\n rm -r     <<< It handles unversioned folders and spaces in filenames


	sudo git clean -nxd
sudo git clean -fxd


sudo git clean -nxd -e "log*" -e "cscope*" -e "patch*" -e "commit*" -e ".git*" -e "change*"      # dry-run to check with grep or some others
sudo git clean -fxd -e "log*" -e "cscope*" -e "patch*" -e "commit*" -e ".git*" -e "change*"      # really remove files
	

	Log
Search
View historical
	svn log
svn log -q file | grep '^r' | cut -f1 -d' '
	git log
git log -3                               <<< by amount
git log --after="2014-7-1"        <<< by date
git log --after="2014-7-1" --before="2014-7-4"
git log --author="John"           <<< by author
git log --author="John\|Mary"
git log --grep="JRA-224:"        <<< by commit message, -i ignore case
git log -- foo.py bar.py             <<< by files
git log -S"Hello, World!"           <<< by patch content
git log master..feature             <<< by range


git log -p filename    <<< with diff file
--stat xxxxxxx..xxxxxxx
--name-status
--name-only
--since "10 Sep 2012" --until "12 Nov 2012" --stat
	

	View old version file
	svn update -r 666 file <<< update version
svn cat -r 666 file | less <<< just view the file directly
	git show <SHA>:<file>
	

	Blame
	svn blame -- <file>
	git blame <SHA> -- <file>    <<< use --follow to make blame follow renames
	

	Revert
<OR>
discard current changes
	svn revert <file>
svn revert -R .     <<< flush all changes
	git checkout HEAD [filenames or directories]
git checkout .       <<< revert changes of working copy
git checkout -- <file>
git reset               <<< revert changes of made to index


git revert …          <<< revert change that have committed


git clean -f            <<< remove all untracked files (e.g., new files, generated files)
git clean -d           <<< remove all untracked directories


	

	

Branch info


	

	git branch -a    <<< show all branch
git branch -r    <<< only show remote branch


=link with same name=
git checkout -t origin/feature    <<< track remote branch as local
git branch -u upstream/foo


=link with diff name=
git branch --track feature1 origin/feature    <<< if want another name
git branch -u upstream/foo foo
	

	Tag
	svn tag
	git tag
	

	stash
	

	$ git stash
...
$ git stash pop


===stash detail===
git stash [save [message] ]
git stash list
git apply stash@{0}
git stash drop stash@{0}


===stash revert===
git stash show -p stash@{0} | git apply -R
	

	Routine
	

	$ git log -p ORIG_HEAD.. dir <<< look at the changes done upstream since last time we checked
$ git pull URL ALL <<< fetch from a specific branch from a specific repository and merge
$ git reset --hard ORIG_HEAD <<< revert the pull
$ git gc <<< garbage collect leftover objects from reverted pull
$ git fetch --tags <<< obtain official tags from the origin and store them under .git/refs/tags/.






	

	



empty commit
That means you are pushing a different history than the one others might have already cloned.
If you are sure that won't be a problem, you need to force the push:


// $ git push -f origin master
$ git commit --allow-empty
You would have created a new (empty) commit, which you could have pushed without any issue.


commands
git log -n 10 --graph --pretty="%h %ad %s(%an)" --date=short
git log --graph --oneline --date-order --decorate --color --all


Q: how to read git log graph
Another interesting thing you can do is visualize the commit graph with the '--graph' option, like so:
$ git log --pretty=format:'%h : %s' --graph
* 2d3acf9 : ignore errors from SIGCHLD on trap
*   5e3ee11 : Merge branch 'master' of git://github.com/dustin/grit
|\
| * 420eac9 : Added a method for getting the current branch.
* | 30e367c : timeout code and tests
* | 5a09431 : add timeout protection to grit
* | e1193f8 : support for heads with slashes in them
|/
* d6016bc : require time for xmlschema
It will give a pretty nice ASCII representation of the commit history lines.




A:
The asterisks show where something was committed:


e1193f8, 5a09431 and 30e367c were committed to the left branch (yielding a | on the right branch) whereas 420eac9 was committed to the right branch (yielding a | on the left branch). And that is what 420eac9 does different from the rest: it's the only commit to the right branch.


For the sake of completeness:


d6016bc was the branching point
5e3ee11 is the merging commit
2d3acf9 is the first commit after merging


Git notes (used as TODOS)


git notes add


$ git notes add HEAD
$ git notes add -m 'I approve - Scott' master~1
$ git log master
Notes:
  I approve - Scott
$ git notes edit master~1


git notes new namespace for default namespace ‘commits’
$ git notes --ref=bugzilla add -m 'bug #15' 0385bcc3       <<< add new notes to a specific namespace, if not exist, create the new notes namespace.
$ git log --show-notes=bugzilla             <<< show notes at specific namespace, not the only ‘commits’
$ git log -1 --show-notes=*                   <<< show notes from all namespace, not only namespace ‘commits’


git push notes
$ git push origin refs/notes/bugzilla      <<< push a specific notes namespace
$ git push origin refs/notes/*                 <<< push all notes namespace, the same as: $ git push origin --tags it basically expands to git push origin refs/tags/*.
$ git fetch origin refs/notes/*:refs/notes/*


git push notes using config
[remote "origin"]
  fetch = +refs/heads/*:refs/remotes/origin/*
  url = git@github.com:schacon/kidgloves.git
  fetch = +refs/notes/*:refs/notes/*


Git submodule
http://www.josephj.com/entry.php?id=342
Git subtree
http://aoxuis.me/posts/2013/08/07/git-subtree/ 
http://blog.kidwm.net/341 
Git Config
Git Config global
$ git config --global user.name "Your Name"
$ git config --global user.email "yname@you.com"
$ git config --global core.excludesfile '~/.gitignore'


$ git config --global core.autocrlf true                <<< Run these git setup commands to avoid choking on Windows newlines
$ git config --global user.name "My Name"
$ git config --global user.email me@mydomain.com
$ git config --global color.diff auto
$ git config --global color.status auto
$ git config --global color.branch auto
$ git config --global color.grep auto
$ git config --global color.interactive auto
$ git config --global color.ui auto




$ cat ~/.gitconfig
[user]
        name = My Name
        email = me@mydomain.com
[color]
        diff = auto
        status = auto
        branch = auto


[remote "mw.com"]
        url = ssh://mydomain.com/home/myusername/shared/myproject.git


$ cat .gitignore
*
!*/
!Makefile
!*.[ch]

[sample2]
*
!*/**/migbase/
!*/**/daemon/wad/
!*/**/daemon/miglogd/
!Makefile
!*.[ch]




Git bundle backup repository
What is the right invocation to:
* Bundle all the branches in the current repo
Simple:
$ git bundle create repo.bundle --all
Here repo.bundle is the name of bundle file you want to create. Note that --all would not include remote-tracking branches... just like ordinary clone wouldn't either.
* Start up the new repo on the destination directory, i.e. get the root commit correctly installed
First, clone is just init + fetch (+ administrativia).
Second, you can use bundle file everywhere the repository URL can be used, so you can simply clone from a bundle file:
$ git clone repo.bundle
This would create repo as a git repository.


Svn dump backup repository


svnrdump dump -q http://scm-yvr.fortinet.com/svn/svnroot/FortiCache/branches/2.x/br_2_rtmp_new/trunk | bzip2 -9 > fch-rtmp.dump.bz2


svnadmin dump is for working on the repository(server side), not the working copy (client side) The errormessage about format is misleading as it searches for the format file in repository and finds a file with same name in your workingcopy.


If you are interested to get a full backup of your repository you can use svnrdump for this purpose. It is used the same way than svnadmin dump, however it is possible to get the dump from an remote repository: use


svnrdump  dump -r0:HEAD [URL_TO_YOUR_REPO] > Your_dumpfile.dmp
THIS IS A NEW SVN 1.7 FEATURE


cd svn-dir
svnadmin dump ./| bzip2 -9 > mybackup.dump.bz2


svnadmin create ./myNewRepo
svnadmin load ./myNewRepo < ./myOldRepo.svndump




Git workflow


git init
cd --your-code-dir--
git init
git add .
git commit -m "Initial commit"


change & commit
edit commit.log: list requirement, function-point, howto test
… edit …
git add -u    <<< the modified files
git add .     <<< the new-added files
git add       <<< stages means ‘add to index’
* git add -A     <<< stages All
* git add .       <<< stages new and modified, without deleted
* git add -u     <<< stages modified and deleted, without new
<OR>
$ git add .      # add to index only files created or modified and not those deleted 
$ git add -u    # add to index only files modified or deleted and not those created 
$ git add -A   # do both operation at once, add to index all files
git commit -F commit.log
Here is a quick summary of what he recommends:
* First line is 50 characters or less
* Then a blank line
* Remaining text should be wrapped at 72 characters
<<< Write commit notes
$ git notes add
# opens the editor to add a note to the last commit
Git notes are annotations for existing commits. They don’t change the history, so you are free to add notes to any existing commits. Your notes are stored only in your repo,
Squash several Git commits into a single commit
$ git checkout -b squashed_feature   // create a new branch
$ … modify and commit 3 times
$ git rebase -i master
pick fda59df commit 1
pick x536897 commit 2
pick c01a668 commit 3


<<< change above info like following:
pick fda59df commit 1
squash x536897 commit 2
squash c01a668 commit 3


$ git checkout master          // change to master branch
$ git merge squashed_feature  // merge from the before branch
git diff author filter
$ (master) git checkout -b temp <SH1-commit1>
$ (temp)   git cherry-pick $(git log --pretty=%H --author=Alice <SH1-commit1>..<SH1-commit2>)
$ (temp)   git diff <SH1-commit1> temp
revert & reset
$ git checkout .    <<< revert changes made to your working copy
$ git reset         <<< revert changes made to the index (i.e., that you have added)
$ git revert ...    <<< revert a change that you have committed


$ git reset --hard  <<< will not remove untracked files
$ git clean -f      <<< remove any files from the tracked root directory that are not under git tracking
This is also especially useful when you get the error message
~"performing this command will cause an un-tracked file to be overwritten"
msg: “unmerged files”
messages:
>>> U      app/models/disclosure_event.rb
>>> fatal: 'commit' is not possible because you have unmerged files.


$ git reset app/models/disclosure_even.rb
$ git add app/models/disclosure_even.rb


git stash

git stash save "guacamole sauce WIP"
git stash apply stash^{/guacamo}


git clean:
sudo git clean -nxd -e "log*" -e "cscope*" -e "patch*" -e "commit*" -e ".git*" -e "change*"      # dry-run to check with grep or some others
sudo git clean -fxd -e "log*" -e "cscope*" -e "patch*" -e "commit*" -e ".git*" -e "change*"      # really remove files


svn status | grep '^?' | awk '{print $2}' | xargs rm -rf
svn status | egrep '^\?' | cut -c 8- | xargs rm
svn status | grep ^\? | cut -c 9- | xargs -d \\n rm -r     <<< It handles unversioned folders and spaces in filenames


make menuconfig
make zkernel > /dev/null && make > /dev/null && make image > /dev/null


working on new branch and merge back


$ git checkout -b myFeature dev-branch        <<< Creates MyFeature branch off dev-branch
$   git commit -am "Your message"   
$ git checkout dev-branch                                <<< Now merge your changes to dev without a fast-forward
$   git merge --no-ff myFeature


$ git push origin dev                                        <<< Now push changes to the server
$ git push origin myFeature


Remote and Branch


Clone all remote branches
1. First, clone a remote Git repository and cd into it:
$ git clone git://example.com/myproject
$ cd myproject

1. Next, look at the local branches in your repository:
$ git branch
* master

1. But there are other branches hiding in your repository! You can see these using the -a flag:
$ git branch -a
* master
 remotes/origin/HEAD
 remotes/origin/master
 remotes/origin/v1.0-stable
 remotes/origin/experimental

1. If you just want to take a quick peek at an upstream branch, you can check it out directly:
$ git checkout origin/experimental

1. But if you want to work on that branch, you'll need to create a local tracking branch:
$ git checkout -b experimental origin/experimental
<or>
$ git checkout -t origin/experimental

1. Now, if you look at your local branches, this is what you'll see:
$ git branch
* experimental
 master

1. You can actually track more than one remote repository using git remote.
$ git remote add win32 git://example.com/users/joe/myproject-win32-port
$ git branch -a
* master
 remotes/origin/HEAD
 remotes/origin/master
 remotes/origin/v1.0-stable
 remotes/origin/experimental
 remotes/win32/master
 remotes/win32/new-widgets

1. At this point, things are getting pretty crazy, so run gitk to see what's going on:
$ gitk --all &
=========================================================================================


1. If you have many remote branches that you want to fetch at once, do:
$ git remote update
$ git pull --all

1. Now you can checkout any branch as you need to, without hitting the remote repository.


Pulling / fetching upstream changes
After working for a while, your master branch will be out of sync with the fos.git upstream branch.
The procedure here will be:
1. Fetch changes in to local mirror:
$ cd ~/mirror/fos.git
$ git fetch
... lots of output ...
From http://cm.fortinet.com/fos
  8e2c6bf..96aa489  br_4_wireless -> br_4_wireless
* [new branch]      tags/fg_4_0057 -> tags/fg_4_0057
  921d34a..a302ae4  fos300      -> fos300

1. Update working copy 1:
$ cd ~/work/300_bug1234
$ git fetch
... output ...
From /home/username/mirror/fos
  921d34a..a302ae4  fos300      -> origin/origin/fos300

1. Rebase, merge, etc (this is back to the normal git workflow at this point).
$ git rebase origin/origin/fos300
$ git merge ...
etc.

Merge Feature Branch to Create an ECO
When merging a branch to main, it would not be uncommon to have a set of feature commits mixed with "merge up" commits, where the branch was iteratively brought in sync with the main trunk. One way to merge such a branch back to the trunk, without too much difficulty, is:
Merge up the branch to the latest build tag (or latest commit, if desired):
1. $ git checkout master (current HEAD of feature branch)
2. $ git rebase --onto HEAD tag_b400 tag_b401 (tag_b400 is the current trunk sync point, tag_b401 is the new trunk sync point)
3. (fix conflicts) 
4. $ git branch -f merge
5. $ git checkout master
6. $ git merge --squash merge
7. $ git commit -m"Merge trunk build 400 to build 401"
8. $ git branch -D merge
9. 10. Create a new branch against the new sync point:
11. $ git branch mergeout tag_b401
12. $ git checkout mergeout
13. $ git merge --strategy subtree --squash master (there should be no conflicts here)
14. $ git commit -m "Merge feature branch br_xxxx"
15. 16. Rebase the merge commit against the latest trunk revision before generating the ECO:
17. $ git rebase origin/svn/trunk
18. (fix conflicts) 
19. 20. Create ECO
21. $ genco_xml.pl -m"Merge feature branch br_xxxx" origin/svn/trunk


________________


The last couple steps for updating working copies...
$ git pull --rebase
should do the fetch+pull/rebase for you in most cases




$ git checkout feature && git rebase @{-1} && git checkout @{-2} && git merge @{-1}        <<< Checkout a branch, rebase and merge to master, The special “@{-n}” syntax means “n-th branch checked out before current one”. When we checkout “feature”, “@{-1}” is a reference to “master”. After rebasing, we need to use “@{-2}” to checkout master because “@{-1}” is a reference to the same branch (“feature”) due to how rebasing works internally.


$ git remote 
$ git remote show origin                <<< show repositon info, like svn info
$ git remote
origin
What origin means
git push origin master
same as:   
git push origin master_on_my_machine:master_on_github
origin is the default name of the remote git repository you cloned from. Have a look at .git/refs/remotes/origin/* and .git/config within your sources to see how git knows about it.


$ git remote add pb git://github.com/paulboone/ticgit.git
$ git remote -v
origin        git://github.com/schacon/ticgit.git
pb        git://github.com/paulboone/ticgit.git
$ git fetch pb                <<< the trunk <master>: pb/master


fetch remote server’s git branch: 
git branch -l -r    #list remote branch, choose what you want
git branch test origin/test
git checkout test
git pull
<or>
git fetch origin             # fetch all branch into local if you want.
get checkout -b test origin/test      # relate local branch to remote branch


checkout: git pull vs fetch
$ git pull,  like git fetch + git merge
$ git fetch + git rebase
merge vs rebase: the log and commit order diffenrent

$ git fetch
more safe, cause we can check status before merge
git fetch origin master
git log -p master..origin/master
git merge origin/master
<OR>
git fetch origin master:tmp
git diff tmp
git merge tmp
$ git pull        <<< fetch+merge
git pull origin master


$ git push -u origin master
$ git checkout -t origin/feature        <<< Easily track a remote branch from someone else
$ git cherry -v master                        <<< See which changes from a branch are already present upstream
$ git branch --contains 50f3754        <<< Find out which branch contains a change
$ git pull --rebase                        <<< Pull with rebase instead of merge


$ git branch -m <oldname> <newname>
$ git clone --depth=1 file:////home/wilson/work/fos_git  fos_study
$ git clone -b 0198879-url-match-config --no-hardlinks /home/wilson/work/fos/.git        <<< clone local git reposition




branch from a spicific commit
> git branch -your-study-branch-name- SHA^
> git checkout -your-study-branch-name-
partial commit | selective commit
$ git add -i                        <<< (select the hunks you want to keep)
$ git commit -m "tmp"                <<< Now you have a commit with only the changes you want to keep, and the rest is unstaged.
$ git reset --hard HEAD        <<< uncommitted changes have been discarded, so you have a clean working directory, with the changes you want to keep committed on top.
$ git reset --mixed HEAD^        <<< removes the last commit ('tmp'), but keeps the modifications in your working directory, unstaged, replaced --soft with --mixed, to clean up the staging area.
Generate a git patch for a specific branch
    >> git branch --contains branch-to-delete
    This will list all branches which contain the commits from "branch-to-delete". If it reports more than just "branch-to-delete", the branch has been merged.
    >> git branch --contains develop | grep "^ *feature$"
    >> git log oldbranch ^newbranch --no-merges
    ...that is, show commit logs for all commits on oldbranch that are not on newbranch. You can list multiple branches to include and exclude, e.g.
    >> git log oldbranch1 oldbranch2 ^newbranch1 ^newbranch2 --no-merges


    Assuming that your branch was created off of master :
    >> git cherry -v master
    or
    >> git log master..
    If your branch was made off of origin/master, then say origin/master instead of master.
git log origin/master
Would be like (fake command):   git log INITIAL..origin/master
While:
git log origin/master..
is:    git log origin/master..HEAD


Git Howtos
git rebase vs git merge
Short Version


Merge takes all the changes in one branch and merge them into another branch in one commit.
Rebase says I want the point at which I branched to move to a new starting point
So when do you use either one?


Merge
Let's say you have created a branch for the purpose of developing a single feature. When you want to bring those changes back to master, you probably want merge (you don't care about maintaining all of the interim commits).
Rebase
A second scenario would be if you started doing some development and then another developer made an unrelated change. You probably want to pull and then rebase to base your changes from the current version from the repo.


experimented with a test repository


It's simple, with rebase you say to use another branch as the new base for your work so...


If you have for example a branch master and you create a branch to implement a new feature, say you name it cool-feature, of course the master branch is the base for your new feature.


Now at a certain point you want to add the new feature you implemented in the master branch. You could just switch to master and merge the cool-feature branch:


$git checkout master
$git merge cool-feature
but this way a new dummy commit is added, if you want to avoid spaghetti-history and of course be sexier you can rebase:


$git checkout master
$git rebase cool-feature
Alternatively if you want to resolve conflicts in your topic branch as VonC suggested you can rebase you branch this way:


$git checkout cool-feature
$git rebase master
and then merge it in master:


$git checkout master
$git merge cool-feature
This time, since the topic branch has the same commits of master plus the commits with the new feature, the merge will be just a fast-forward ;)


Now the question is...is it correct? Is rebase just a smarter merge? Did I understand it well or I was dreaming? It's difficult to find good documentation on rebase. I hope this will help and it's correct.
rollback | reset


revert all local changes
git checkout .    <<< If you want to revert changes made to your working copy
git reset             <<< If you want to revert changes made to the index (i.e., that you have added)
git revert …       <<< If you want to revert a change that you have committed


git revert vs reset
* revert 比较和善，是将之前某次提交反转不算数，但后续可逆
* reset 则是直接将之前提交丢弃, 可使用git reflog将reset后的内容恢复


$ git reset --hard HEAD
$ svn revert foo.c        <<< revert changes to a file
$ svn revert -R .        <<< revert a whole directory of files


git revert …                // If you want to revert a change that you have committed, do this:
git checkout -- .        // If you want to revert changes just made to your working copy, that’s means: Drop changes in the tree, keep index.
git reset                // If you want to revert changes made to the index (i.e., that you have added), do this:
git reset [<mode>] [<commit>]
This form resets the current branch head to <commit> and possibly updates the index (resetting it to the tree of <commit>) and the working tree depending on <mode>. If <mode> is omitted, defaults to "--mixed". The <mode> must be one of the following:
--soft                <<< Does not touch the index file nor the working tree at all (but resets the head to <commit>, just like all modes do). This leaves all your changed files "Changes to be committed", as git status would put it.
--mixed        <<< Resets the index but not the working tree (i.e., the changed files are preserved but not marked for commit) and reports what has not been updated. This is the default action.
--hard                <<< Resets the index and working tree. Any changes to tracked files in the working tree since <commit> are discarded.
--merge                <<< Resets the index and updates the files in the working tree that are different between <commit> and HEAD, but keeps those which are different between the index and working tree (i.e. which have changes which have not been added). If a file that is different between <commit> and the index has unstaged changes, reset is aborted. In other words, --merge does something like a git read-tree -u -m <commit>, but carries forward unmerged index entries.
--keep                <<< Resets index entries and updates files in the working tree that are different between <commit> and HEAD. If a file that is different between <commit> and HEAD has local changes, reset is aborted.
checkout vs. reset
* A commit holds a certain state of a directory and a pointer to its antecedent commit.
* A commit is identified by a so-called ref looking something like 7153617ff70e716e229a823cdd205ebb13fa314d.
* HEAD is a pointer that is always pointing at the commit you are currently working on. Usually, it is pointing to a branch which is pointing to that commit.
* Branches are nothing but pointers to commits. You are 'on a branch' when HEAD is pointing to a branch.
checkout
git checkout <commit> <paths> tells git to replace the current state of paths with their state in the given commit.
* paths can be files or directories.
* If no branch (or commit hash, see basic facts) is given, git assumes the HEAD commit.
   * –> git checkout <path> restores path from your last commit. It is a 'filesystem-undo'.
* If no path is given, git moves HEAD to the given commit (thereby changing the commit you're sitting and working on).
   * –> git checkout branch means switching branches.
* Example: git checkout HEAD~2 app/models/foo.rb drops all modifications of foo.rb and replaces the file with its version two commits ago.
reset
git reset <commit> re-sets the current pointer to the given commit.
* If you are on a branch (you should usually be), HEAD and this branch are moved to commit.
* If you are in detached HEAD state, git reset does only move HEAD. To reset a branch, first check it out.
* Example: You are currently working upon commit 123abc. After resetting to a previous commit xyz789 (e.g. with git reset HEAD~2), you have no easy access to commit 123abc anymore, because HEAD and the branch are both pointing to xyz789. To move the branch pointer 'back to the front', you can't use git checkout, as it only moves HEAD. You have to reset your branch to that commit: git reset 123abc. (If you didn't save the first commit's hash (123abc), git reflog will help you finding it.)


How can I roll back 1 commit?


I have 2 commits that I did not push:


$ git status
# On branch master
# Your branch is ahead of 'faves/master' by 2 commits.
How can I roll back my first one (the oldest one), but keep the second one?


$ git log
        commit 3368e1c
        ...
        commit baf8d5e


Do I just need to do:


$ git reset --hard baf8d5e7da9e41fcd37d63ae9483ee0b10bfac8e






The safest and probably cleanest way to go is to rebase interactively.


git rebase -i HEAD^^
Or,


git rebase -i baf8d5e7da9e41fcd37d63ae9483ee0b10bfac8e^
From there you can squash commits, which puts one or more commits together into the previous commit. To completely delete a commit from the history, delete the line from the list.


You can revert a commit with git revert but its going to add more commit messages to the history, which may be undesirable. Use the -n parameter to tell Git not to commit the revert right away. You can rebase interactively and squash those on up to a previous commmit to keep things clean.


If the two commits you're working with here affect the same file(s), you may see a merge conflict.


Resetting the repository with git reset --hard should be done with care, as it cannot be undone.


Rewriting history should be done with care.








Git Delete Last Commit


Once in a while late at night when I ran out of coffee, I commit stuff that I shouldn't have. Then I spend the next 10 - 15 minutes googling how to remove the last commit I made. So after third time I wanted to make a record of it so I can refer to it later.


If you have committed junk but not pushed,


git reset --hard HEAD~1


HEAD~1 is a shorthand for the commit before head. Alternatively you can refer to the SHA-1 of the hash you want to reset to. Note that when using --hard any changes to tracked files in the working tree since the commit before head are lost.


If you don't want to wipe out the work you have done, you can use --soft option that will delete the commit but it will leave all your changed files "Changes to be committed", as git status would put it.


Now if you already pushed and someone pulled which is usually my case, you can't use git reset. You can however do a git revert,


git revert HEAD


This will create a new commit that reverses everything introduced by the accidental commit.






Git Revert vs Checkout vs Reset?


I am trying to learn how to restore or rollback files and projects to a prior state, and don't understand the difference between git revert, checkout, and reset. Why are there 3 different commands for seemingly the same purpose, and when should someone choose one over the other?


As I have no experience with subversion or other centralized version control software, reference to how they did things differently is unnecessary and often confusing.




Git revert is used to undo a previous commit. In git, you can't alter or erase an earlier commit. (Actually you can, but it can cause problems.) So instead of editing the earlier commit, revert introduces a new commit that reverses an earlier one.
Git reset is used to undo changes in your working directory that haven't been comitted yet.
Git checkout is used to copy a file from some other commit to your current working tree. It doesn't automatically commit the file.






These three commands have entirely different purposes. They are not even remotely similar.


git revert


This command creates a new commit that undoes the changes from a previous commit. This command adds new history to the project (it doesn't modify existing history).


git checkout


This command checks-out content from the repository and puts it in your work tree. It can also have other effects, depending on how the command was invoked. For instance, it can also change which branch you are currently working on. This command doesn't make any changes to the history.


git reset


This command is a little more complicated. It actually does a couple of different things depending on how it is invoked. It modifies the index (the so-called "staging area"). Or it changes what commit a branch head is currently pointing at. This command may alter history (by changing the commit that a branch references).


Using these commands


If a commit has been made somewhere in the project's history, and you later decide that the commit is wrong and should not have been done, then git revert is the tool for the job. It will undo the changes introduced by the bad commit, recording the "undo" in the history.


If you have modified a file in your working tree, but haven't committed the change, then you can use git checkout to checkout a fresh-from-repository copy of the file.


If you have made a commit, but haven't shared it with anyone else and you decide you don't want it, then you can use git reset to rewrite the history so that it looks as though you never made that commit.


These are just some of the possible usage scenarios. There are other commands that can be useful in some situations, and the above three commands have other uses as well.






Git: Never Commit a certain file (But still keep original revisioned.)
$ git update-index --assume-unchanged <file>        <<<  temporarily ignore changes in a certain file
$ git update-index --no-assume-unchanged <file>        <<< Then when you want to track changes again:
But  you git add the file directly, it will be added to the index. Merging a commit with this flag on will cause the merge to fail gracefully so you can handle it manually.
Tags


$ git tag -m "Message for log" "my-tag-name"
$ git log --pretty=oneline -3  // find SHA1
$ git tag v1.0 ec32d32    // add
$ git tag -d v1.0              // delete
$ git push origin --tags   // push to remote


solve rebase conflict
conflict:
$ git status                        <<< check the confict info
$ vim app/models/user.c          <<< solve conflict  
$ git add app/models/user.rb
$ git commit -c <id>
rebase conflict
$ git checkout master
$ git pull
$ git checkout your-feature
$ git rebase master
…..conflict.......
method 1:
> git mergetool
method 0:
> git checkout --ours filename.c        <<< [this is the reposit master newer version, maybe need use this to use the master’s version, and copy your modify to this file]
> git checkout --theirs filename.c        <<< [this is the your local repos version]
> git add filename.c                        <<< After you have solve the conflict
> git rebase --continue




Git log & diff


git format-patch -1 <sha>
git diff bbc2845 -- . > patch.diff                <<< Difference between a git commit and the working directory
git diff 66f93d7..f1ba363
git diff --name-only SHA1 SHA2
git diff --name-only HEAD~10 HEAD~5
git log --name-status --oneline [SHA1 [SHA2]]
git diff --name-status [SHA1 [SHA2]]
$ git diff origin/master...HEAD
$ git diff --name-status master..branch
$ git diff --stat --color master..branchName
$ git log --pretty=format:"%h - %an, %ar : %s"
ca82a6d - Scott Chacon, 11 months ago : changed the version number
085bb3b - Scott Chacon, 11 months ago : removed unnecessary test code
a11bef0 - Scott Chacon, 11 months ago : first commit
$ git log --oneline --graph --color --all --decorate
$ git log --graph --decorate --date=relative --all --pretty='%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(bold yellow)%d%C(reset)'


search commit message
$ git show :/fix                                
$ git show :/^Merge
# shows the last merge commit


command compaire files


$ diff -u -I 'revision' 5tr_40c/patch.diff 5tr/patch.diff | vim -        <<< compare two diff-files
        -u unified context, 
        -I RE, ignore changes whose lines all match RE
        -p show which c function each change is in
        -w ignore all white space, -B ignore changes whose lines are all blank
        -D/--ifdef   <<< can generate enclose by #ifdef


Git reflog vs log


git reflog 可以查看所有分支的所有操作记录（包括（包括commit和reset的操作），包括已经被删除的commit记录，git log则不能察看已经删除了的commit记录
具体一个例子，假设有三个commit， git st:
commit3: add test3.c
commit2: add test2.c
commit1: add test1.c
如果执行git reset --hard HEAD~1则 删除了commit3，如果发现删除错误了，需要恢复commit3，这个时候就要使用
git reflog
 HEAD@{0}: HEAD~1: updating HEAD
63ee781 HEAD@{1}: commit: test3:q
运行git log则没有这一行记录
可以使用git reset --hard 63ee781将红色记录删除，则恢复了cmmit3，运行git log后可以看到：
commit3: add test3.c
commit2: add test2.c
commit1: add test1.c
这里也可以使用另外一种方法来实现：git cherry-pick 63ee781


view changes only for a branch?
Assuming that your branch was created off of master :
git cherry -v master
or
git log master..
git log --no-merges master..
If your branch was made off of origin/master, then say origin/master instead of master.
but if you update the master, it’s hard to get diff-file just for your branch:
git checkout new-branch
...after several commit...
git log -n 3 --pretty=format:”%h%x09%an%x09%ad%x09%s”         # to find the commit hash-id just before this branch’s first commit
0. what you should do is find diff between your newest commit with the commit before your oldest commit
1. git log master.. --oneline                   # to find the oldest commit of your branch’s commit , assume it as ‘ad1123’
2. git log ad1123~2..HEAD --oneline    # to find the commit before your oldest  commit, assume it as ‘ad0000’
3. git diff ad0000..ad1123                    # this is the diff of your branch’s change


git diff -U10|dwdiff --diff-input -c|less -R
git diff -w   => ignore whitespace
git diff -W   => show the context function
git diff -U   => show more context before and after the diff-line
dwdiff is another tools, you should install it before use, better than wdiff
method 1
1. git log master.. --oneline                   # to find the oldest commit of your branch’s commit , assume it as ‘ad1123’
2. git log ad1123~2..HEAD --oneline    # to find the commit before your oldest  commit, assume it as ‘ad0000’
3. git diff ad0000..ad1123                    # this is the diff of your branch’s change
method 2
or just use one command
git --no-pager log --children -n6 HEAD --oneline
make diff ignore some files or file’s lines according some pattern
What you really want to do is to unset the diff attribute, not set it to a bogus command. Try this in your .gitattributes:
Project.xcodeproj/* -diff
or
You may use an alias in your .git/config
[alias]
        mydiff = !git diff | filterdiff -x "*/Project.xcodeproj/*"
You need filterdiff (from patchutils) for this trick.
sudo apt-get install patchutils
Patchutils contains a collection of tools for manipulating patch files: interdiff, combinediff, flipdiff, filterdiff, fixcvsdiff, rediff, lsdiff, grepdiff, splitdiff, recountdiff, and unwrapdiff. You can use interdiff to create an incremental patch between two patches that are against a common source tree, combinediff for creating a cumulative diff from two incremental patches, and flipdiff to transpose two incremental patches. filterdiff is for extracting or excluding patches from a patch set based on modified files matching shell wildcards. lsdiff lists modified files in a patch. rediff, recountdiff, and unwrapdiff correct hand-edited (or otherwise broken) patches.




Git/svn blame
Svn blame
if you want to check specific “match-str”, which can do like this way:
svn blame --your-file-- | grep “match-str”
  5x  svn blame --your-file | grep match-str
 76846      kwang         struct some-struct *ptr;
 76846      kwang                         ptr = function();
svn diff -c 76846 | vim -          <<< check the patch of this commit.
ECO number


$ svn blame <file> [-rXXX] | vim -        <<< find that modify lines, and the first field is the revision XXXX
$ svn blame <file>[@XXX] | vim -        <<< find that modify lines, and the first field is the revision XXXX


$ svn log -rXXXX                        <<< r101766 | hyu | 2013-08-29 12:12:24 -0700 (Thu, 29 Aug 2013) | 9 lines, 
hyu-5436-fix Explicit Proxy add/remove HTTP headers <<< the 5436 is eco-number


Git blame
http://zsoltfabok.com/blog/2012/02/git-blame-line-history/


git blame --your-file-- | grep “match-str”   <<< find the commit SHA
git show --sha-- | vim -
“blame” a deleted line
$ git log -S<string> -- file        <<< know the delete content
$ git log -G<string> -- file         <<< same thing with regular expressions!
$ git blame --reverse -- file        <<< Walk history forward instead of backward.
$ git blame -L10,+1 fe25b6d^ -- src/options.cpp        <<< blame according line, and also start from a revision (instead of the default of HEAD); fe25b6d^is the parent of fe25b6d.
todo list: 
two kind-of dir:  summit-dir, working-dir, please keep them update-sync as svn-update==git.master.HEAD
working on your working-dir, add @todo @fixme @note @code, @test up to you, for example, you can add your code comment like this:
//@note wad_vd: vdom config data
//@note   - store: add into wad_vd_list and wad_vds-hashmap
//@note   - iter:  wad_vd_iter[2]
//@note   - pwd:   wad_vd_get_cur_vd()
//@note   - find:  wad_vd_find/findname()




apply patch failed


$ git apply -v --check fix_empty_poster.patch 
        error: patch failed: mm/vmalloc.c:469
        error: mm/vmalloc.c: patch does not apply
        Patch failed at file.patch.


$ git apply --reject --whitespace=fix file.patch    <<<  By using “git apply” with the –reject it will apply the patch leaving bad files with “xxx.rej” in my case mm/Kconfig.rej was the culprit. I resolved the problem with mm/Kconfig. Next I tried “git am –resolved”:


$ git am --resolved
* Did you forget to use 'git add'?
* When you have resolved this problem run "git-am --resolved".
* If you would prefer to skip this patch, instead run "git-am --skip"


rebase to a specific commit?
You can avoid using the --onto parameter by making a temp branch on the commit you like and then use rebase in it's simple form:
git branch temp master^
git checkout topic
git rebase temp
git branch -d temp




Svn
svn status -q
        
U: Working file was updated
G: Changes on the repo were automatically merged into the working copy
M: Working copy is modified
C: This file conflicts with the version in the repo
?: This file is not under version control
!: This file is under version control but is missing or incomplete
A: This file will be added to version control (after commit)
A+: This file will be moved (after commit)
D: This file will be deleted (after commit)
S: This signifies that the file or directory has been switched from the path of the rest of the working copy (using svn switch) to a branch
I: Ignored
X: External definition
~: Type changed
R: Item has been replaced in your working copy. This means the file was scheduled for deletion, and then a new file with the same name was scheduled for addition in its place.


list
$ svn help [item]
$ svn ls url
$ svn list --verbose https://www.thegeekstuff.com/project/branches/release/migration/data/bin
 16 sasikala        28361         Apr 16 21:11 README.txt
21 sasikala         0         Apr 18 12:22 INSTALL
22 sasikala                Apr 18 10:17 src/
$ svn co -r1019 https://www.thegeekstuff.com/project/branches/release/migration/data/cfg /home/sasikala/cfg/


$ svn info       <<< show configuration-url and current version
$ svn up[date]        <<< Updates working copy from repository.
$ svn st[atus] | grep  -v ‘^?’ 
$ svn add [path]     <<< Adds new files/directories to SVN.
$ svn revert [file or path]
$ svn resolve --accept working <FILENAME>
$ svn c[omm]i[t] -m “msg”   <<< Checks in changes.


$ svn log -l 10 [file]
$ svn log -r 1:HEAD
$ svn log -r HEAD:1
$ svn log -r {2011-02-02}:{2011-02-03}
$ svn log -v --l 4
r58687 | mr_x | 2012-04-02 15:31:31 +0200 (Mon, 02 Apr 2012) | 1 line Changed
paths: 
A /trunk/java/App/src/database/support    
A /trunk/java/App/src/database/support/MIGRATE    
A /trunk/java/App/src/database/support/MIGRATE/remove_device.sql




$ svn di[ff] Shows how working copy differs from last update (line-by-line).
$ svn diff -x -p    <<< like git diff to show the c outer function name
$ svn diff -r 578 [file]
$ svn diff -r 578:592 [file] [--summarize]
$ svn diff -c --number--   <<< view diff of the commit


Svn conflict

  [1]: http://mislav.uniqpath.com/2010/07/git-tips/
  [2]: http://git.or.cz/course/svn.html

