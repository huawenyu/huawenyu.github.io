---
layout: post
title:  "gdb"
date:   2017-02-16 13:31:01 +0800
categories: linux
tags: gdb
---

* content
{:toc}


# Quick Start:

  - [Gdbserver][1],
  - GUI front-end: [neovim][5], eclipse, others(insight, nemiver)

# Useful command:

## most useful

```c
    handle SIGUSR2 noprint nostop
    watch *(int *) 0x600850		**break if the address's value changed**
    print (int)&((struct A*)0)->a	struct member’s offset
    p *array@len			int *array = malloc (5 * sizeof(int))
```

```c
  - handle SIGUSR2 noprint nostop
  - p *array@len
```

## normal useful

    set print pretty on			 Prints out prettily formatted C source code
    set logging on			 Log debugging session to show to others for support
    set print array on			 Pretty array printing
    set height 0 <or> set pagination off	: disable the "Type <return> to continue, or q <return> to quit" pagination prompt in GDB

backtrace full		: Complete backtrace with local variables
up, down, frame	: Move through frames
br  -> fin -> bt		: use fin to show function’s return value, <or> break at function’s return
finish			: Continue till end of function
until location		: run to somewhere
enable and disable	: Enable/disable breakpoints
tbreak			: Break once, and then remove the breakpoint
rbreak			: break on function matching regular expression
(gdb) rbreak file.c:.
(gdb) rbreak file.cpp:.*StudentClass.*
set substitute-path /usr/src/include /mnt/include	: match different src path
where			: Line number currently being executed
list			: view source
info locals		: View all local variables
set args
info args		: View all function arguments
handle SIGUSR1 noprint nostop
thread apply all bt <or> thread apply all print $pc	: For finding out quickly what all threads are doing.
define hook-stop	: define user commands, <hook-stop> auto-exec when stop, <setup> auto-exec when gdb start
printf “%d” i
refresh
echo hello\n
End


TUI
wh			Enter TUI, but now cannot leave TUI mode use command
Ctrl-x a		switch tui-mode, then should focus cmd, convinient for your use, in tui-mode, cannot use log-redirect
Ctrl+C			if enter <TAB> and make gdb dead-like, you can enter this to interrupt current command and back to gdb interact win
layout src		Standard layout—source on top, command window on the bottom
layout asm		Just like the "src" layout, except it's an assembly window on top
layout split		Three windows: source on top, assembly in the middle, and command at the bottom
layout reg		Opens the register window on top of either source or assembly, whichever was opened last
tui reg general	Show the general registers
tui reg float		Show the floating point registers
tui reg system	Show the "system" registers
tui reg next		Show the next page of registers


# commands
[doc][2][3]

## ignore signal
For the same SIGUSR1 example above, you can query the gdb handler rules like so:

(gdb) info signal SIGUSR1
Signal        Stop      Print   Pass to program Description
SIGUSR1       Yes       Yes     Yes             User defined signal 1
And if deemed to not be of interest, where you just want your program to continue without prompting or spamming, something like the following does the trick:

(gdb) handle SIGUSR2 noprint nostop
Signal        Stop      Print   Pass to program Description
SIGUSR1       No        No      Yes             User defined signal 1

disassemble from address
when crash, we can address (such as 0x090b5c6b) and registers list, then:
list *0x090b5c6b		 view the related source code if the exe is debug version, or we have init.map file
disas /m function		 print mixed source+disassembly by specifying the /m modifier, and the function come from list
disas 0x090b5c6b,+10		 list disassemble from begin-addr to end-addr
disas 0x090b5c6b		 list current function’s disassemble
x/5i 0x090b5c6b		 list disassemble, like disas start,start+5

one step in ASM
(gdb) display/4i $pc
(gdb) x/10x $sp       	 check the stack in HEX
(gdb) x/10xb &buff[0]       	 check buffer in HEX onebye by one
(gdb) ni
(gdb) si
(gdb) undisplay <ID>
(gdb) <OR>   disable display <ID>

batch-mode
$ gdb --batch --command=test.gdb --args ./test.exe 5
Set a debugger variable to a value.
(idb) set variable node->_data = 5
(idb) set variable $address = &(node->_data)
(idb) set variable *(int *)($address) = 1024
save br
save breakpoints --your-file--   	 save your config|breakpoints into file and load next times
source --your-file--
del br 1-11     	 batch clear breakpoint
break WHERE if COND  	 breakpoints' condition
command  	 In addition to conditional breakpoints, add commands run every time when hit a breakpoint
watch *(int *) 0x600850 	 also pos­si­ble to watch a spe­cific mem­ory address with the syn­tax: watch *0xdeadbeaf. A watch­point trig­gers when the con­tents of the mem­ory loca­tion changes, so they are use­ful when try­ing to find out when a vari­able is mod­i­fied. 
print check data
x/10x $sp       	 check the stack in HEX
x/x displays elements in hex, x/d displays them as signed decimals, x/c displays characters, x/i disassembles memory as instructions, and x/s interprets memory as C strings.
x/s 0xffffffff81946000
x/5i main
x/s <stringname>  	 examine an ansistring?

p/x x
p (int [3]) *a  	 $8 = {1, 2, 3}
p *a@3        	 $11 = {1, 2, 3}

gdb start
options
-symbols file
-core file
-command file
-directory directory
-batch				 from shell to disassembly specific function:  gdb sysinit/init  -batch -ex 'disas /m wad_url_match_get_host_seg'

gdb Automatic batch commands

method 1: .gdbinit
gdb executes file .gdbinit after running

method 2: hit breakpoint automatic execute batch commands
I wanted to get some variable values in particular places of the code; and have them output until the program crashes. So here is first a little program which is guaranteed to crash in a few steps,test.c:
#include <stdio.h>
#include <stdlib.h>

int icount = 1; // default value

main(int argc, char *argv[])
{
  int i;

  if (argc == 2) {
    icount = atoi(argv[1]);
  }

  i = icount;
  while (i > -1) {
    int b = 5 / i;
    printf(" 5 / %d = %d \n", i, b );
    i = i - 1;
  }

  printf("Finished\n");
  return 0;
}


The only reason the program accepts command-line arguments is to be able to choose the number of steps before crashing - and to show that gdb ignores --args in batch mode. This I compile with:
gcc -g test.c -o test.exe


Then, I prepare the following script - the main trick here is to assign a command to each breakpoint, which will eventually continue (see also Automate gdb: show backtrace at every call to function puts). 
script file:  test.gdb
# http://sourceware.org/gdb/wiki/FAQ: to disable the
# "---Type <return> to continue, or q <return> to quit---"
# in batch mode:
set width 0
set height 0
set verbose off

# at entry point - cmd1
b main
commands 1
  print argc
  continue
end

# printf line - cmd2
b test.c:17
commands 2
  p i
  p b
  continue
end

# int b = line - cmd3
b test.c:16
commands 3
  p i
  p b
  continue
end

# show arguments for program
show args
printf "Note, however: in batch mode, arguments will be ignored!\n"

# note: even if arguments are shown;
# must specify cmdline arg for "run"
# when running in batch mode! (then they are ignored)
# below, we specify command line argument "2":
run 2     # run

#start # alternative to run: runs to main, and stops
#continue


use it in batch mode or normal mode
Note that, if you intend to use it in batch mode, you have to "start up" the script at the end, with run or start or something similar.
With this script in place, I can call gdb in batch mode - which will generate the following output in the terminal:
$ gdb --batch --command=test.gdb --args ./test.exe 5

Breakpoint 1 at 0x804844d: file test.c, line 10.
Breakpoint 2 at 0x8048485: file test.c, line 17.
Breakpoint 3 at 0x8048473: file test.c, line 16.
Argument list to give program being debugged when it is started is "5".
Note, however: in batch mode, arguments will be ignored!

Breakpoint 1, main (argc=2, argv=0xbffff424) at test.c:10
10    if (argc == 2) {
$1 = 2

Breakpoint 3, main (argc=2, argv=0xbffff424) at test.c:16
16      int b = 5 / i;
$2 = 2
$3 = 134513899

Breakpoint 2, main (argc=2, argv=0xbffff424) at test.c:17
17      printf(" 5 / %d = %d \n", i, b );
$4 = 2
$5 = 2
 5 / 2 = 2 

Breakpoint 3, main (argc=2, argv=0xbffff424) at test.c:16
16      int b = 5 / i;
$6 = 1
$7 = 2

Breakpoint 2, main (argc=2, argv=0xbffff424) at test.c:17
17      printf(" 5 / %d = %d \n", i, b );
$8 = 1
$9 = 5
 5 / 1 = 5 

Breakpoint 3, main (argc=2, argv=0xbffff424) at test.c:16
16      int b = 5 / i;
$10 = 0
$11 = 5

Program received signal SIGFPE, Arithmetic exception.
0x0804847d in main (argc=2, argv=0xbffff424) at test.c:16
16      int b = 5 / i;


Note that while we specify command line argument 5, the loop still spins only two times (as is the specification of run in the gdb script); if run didn't have any arguments, it spins only once (the default value of the program) confirming that --args ./test.exe 5 is ignored.
However, since now this is output in a single call, and without any user interaction, the command line output can easily be captured in a text file using bash redirection, say:
gdb --batch --command=test.gdb --args ./test.exe 5 > out.txt


There is also an example of using python for automating gdb in c - GDB auto stepping - automatic printout of lines, while free running?
Hope this helps,
Cheers!

gdb tricks

rwatch [-l|-location] expr [thread threadnum] [mask maskvalue]
	Set a watchpoint that will break when the value of expr is read by the program.

awatch [-l|-location] expr [thread threadnum] [mask maskvalue]
Set a watchpoint that will break when expr is either read from or written into by the program.


info watchpoints [n...]
	This command prints a list of watchpoints, using the same format as info break (see Set Breaks).

set batch-cmd to existed breakpoint: (gdb) command 1		 assume break-num =#1
set conditional to existed breakpoint: (gdb) cond 1 strcmp ( $secret_code, c ) == 0		 assume break-num =#1

In addition to conditional breakpoints, the command command lets you specify commands to be run every time you hit a breakpoint. This can be used for a number of things, but one of the most basic is to augment points in a program to include debug output, without having to recompile and restart the program. I could get a minimal log of every mmap() operation performed on a system using:

In gdb
(gdb) b do_mmap_pgoff 
Breakpoint 1 at 0xffffffff8111a441: file mm/mmap.c, line 940.
(gdb) command 1
Type commands for when breakpoint 1 is hit, one per line.
End with a line saying just "end".
>silent
>print addr
>print len
>print prot
>set x=y+4
>cont
>end
(gdb)

use script
$ cat yourbreaks.gdb
set confirm off                                                                                             
delete								 clear all old breaks, but need confirm, so close confirm first
set confirm on                                                                                              
                                                                                                            
br wad_tcp_port.c:602 if tcp_port.fd == 39           	 keyword commands start
commands                                                                                                    
silent                                                                                                      
print *tcp_port                                                                                             
br wad_tcp_port_proc_end					 if cond-true, enable this breakpoint
cont                                                                                                        
end  								 keyword end EOF commands

(gdb) source yourbreaks.gdb		 import the breaks with condition
(gdb) info br		 view breaks
examine memory
Use the x command to examine memory. The syntax for the x command is x/FMT ADDRESS. The FMT field is a count followed by a format letter and a size letter. There are many options here, use the help command 'help x' to see them all. The ADDRESS argument can either be a symbol name, such as a variable, or a memory address.
If we have char *s = "Hello World\n", some uses of the x command could be:
Examine the variable as a string:
(gdb) x/s s
0x8048434 <_IO_stdin_used+4>:    "Hello World\n"


Examine the variable as a character:
(gdb) x/c s
0x8048434 <_IO_stdin_used+4>:   72 'H'


Examine the variable as 4 characters:
(gdb) x/4c s
0x8048434 <_IO_stdin_used+4>:   72 'H'  101 'e' 108 'l' 108 'l'


Examine the first 32 bits of the variable:
(gdb) x/t s
0x8048434 <_IO_stdin_used+4>:   01101100011011000110010101001000


Examine the first 24 bytes of the variable in hex:  /3x  show 3 integer
(gdb) x/3x s
0x8048434 <_IO_stdin_used+4>:   0x6c6c6548      0x6f57206f      0x0a646c72


registers?
Use the info registers command. The output of this command depends on the hardware architecture. The following is part of the output on an intel machine:
(gdb) info registers
eax            0x40123460       1074934880
ecx            0x1      1
edx            0x80483c0        134513600
ebx            0x40124bf4       1074940916
esp            0xbffffa74       0xbffffa74
ebp            0xbffffa8c       0xbffffa8c
esi            0x400165e4       1073833444
...


[continue and step][4]

u location
Continue running your program until either the specified location is reached, or the current stack frame returns. location is any of the forms described in Specify Location. This form of the command uses temporary breakpoints, and hence is quicker than until without an argument. The specified location is actually reached only if it is in the current frame. This implies that until can be used to skip over recursive function invocations. For instance in the code below, if the current location is line 96, issuing until 99 will execute the program up to line 99 in the same invocation of factorial, i.e., after the inner invocations have returned.

~/.gdbinit
set print pretty on
set print elements 0
set print sevenbit-strings off
set print union on
set print object on
set print static-members on
set print vtbl on
set print demangle on
set demangle-style gnu-v3
#set trace-commands on
#set logging on
#set logging overwrite
#set logging redirect
#show logging

print char*
set print elements 0
From the GDB manual:
set print elements number-of-elements
Set a limit on how many elements of an array GDB will print. If GDB is printing a large array, it stops printing after it has printed the number of elements set by the set print elements command. This limit also applies to the display of strings. When GDB starts, this limit is set to 200. Setting number-of-elements to zero means that the printing is unlimited.

As long as your program's in a sane state, you can also call (void)puts(your_string) to print it to stdout. Same principle applies to all functions available to the debugger, actually.

registers and others
$_          x command set to the last address examined
$__         x command set to the value found in the last address examined
$_exitcode  set to the exit code when the program being debugged terminates.
$_siginfo   bound to extra signal information inspection

info registers       all registers except floating-point and vector registers (in the selected stack frame).
info all-registers   all registers
info registers regname …   specified register regname

register names 
    $pc program counter register
    $sp stack pointer
    $fp current stack frame
    $ps processor status

p /x $pc       // print the program counter in hex with
x 3/i $pc       // print the instruction to be executed next 3 with
set $sp += 4  // add four to the stack pointer(10)

  [1]: https://sourceware.org/gdb/onlinedocs/gdb/gdbserver-man.html
  [2]: https://sourceware.org/gdb/wiki/FAQ
  [3]: https://blogs.oracle.com/ksplice/entry/8_gdb_tricks_you_should
  [4]: http://sourceware.org/gdb/onlinedocs/gdb/Continuing-and-Stepping.html
  [5]: https://github.com/huawenyu/neogdb.vim
